import net.fabricmc.loom.task.RemapJarTask
import org.apache.commons.codec.digest.DigestUtils
import org.kohsuke.github.GHReleaseBuilder

buildscript {
    dependencies {
        classpath 'org.kohsuke:github-api:1.135'
        classpath 'commons-codec:commons-codec:1.6'
    }
}
plugins {
    id 'fabric-loom' version '0.11-SNAPSHOT'
    id 'maven-publish'
    id "com.matthewprenger.cursegradle" version "1.4.0"
    id "org.ajoberstar.grgit" version "3.1.0"
}

def dontInclude = [
        "thonkutil-additional-capes-v1"
]
//def dontUse = [
//        "thonkutil-unittests"
//]
def ENV = System.getenv()
version = project.properties["thonkutil-version"] + "+" + (ENV.GITHUB_RUN_NUMBER ? "" : "local-") + getBranch();

def getDontUse() {
    return  ["thonkutil-unittests"]
}
def moduleDependencies(project, List<String> depNames) {
    def deps = depNames.iterator().collect { project.dependencies.project(path: ":$it", configuration: 'namedElements') }
    project.dependencies {
        deps.each {
            api it
        }
    }

    if (project.name in dontUse) return

    // As we manually handle the maven artifacts, we need to also manually specify the deps.
    project.publishing {
        publications {
            mavenJava(MavenPublication) {
                pom.withXml {
                    System.out.println(project.name);
                    asNode().appendNode("name", project.group + ":" + project.name)
                    asNode().appendNode("description", "Module for ThonkUtil")
                    asNode().appendNode("url", "https://github.com/LimeAppleBoat/ThonkUtil/")
                    def licenses = asNode().appendNode("licenses")
                    def license = licenses.appendNode("license")
                    license.appendNode("name", "CC0 1.0 Universal")
                    license.appendNode("url", "https://github.com/LimeAppleBoat/ThonkUtil/blob/1.18/LICENSE")
                    def developers = asNode().appendNode("developers")
                    def developer = developers.appendNode("developer")
                    developer.appendNode("name", "Joseph Yap")
                    developer.appendNode("email", "joseph_calvin_yap@hotmail.com")
                    developer.appendNode("organization", "LimeAppleBoat")
                    developer.appendNode("organizationUrl", "https://github.com/LimeAppleBoat")
                    def scm = asNode().appendNode("scm")
                    scm.appendNode("connection", "scm:git:git://github.com/LimeAppleBoat/ThonkUtil.git")
                    scm.appendNode("developerConnection", "scm:git:ssh://github.com:LimeAppleBoat/ThonkUtil.git")
                    scm.appendNode("url", "https://github.com/LimeAppleBoat/ThonkUtil/tree/1.18/")
                    def depsNode = asNode().appendNode("dependencies")
                    deps.each {
                        def depNode = depsNode.appendNode("dependency")
                        depNode.appendNode("groupId", it.group)
                        depNode.appendNode("artifactId", it.name)
                        depNode.appendNode("version", it.version)
                        depNode.appendNode("scope", "compile")
                    }
                }
            }
        }
    }
}

def getBranch() {
    def ENV = System.getenv()
    if (ENV.GITHUB_REF) {
        def branch = ENV.GITHUB_REF
        return branch.substring(branch.lastIndexOf("/") + 1)
    }

    if (grgit == null) {
        return "unknown"
    }

    def branch = grgit.branch.current().name
    return branch.substring(branch.lastIndexOf("/") + 1)
}


import org.kohsuke.github.GitHub;

def getSubprojectVersion(project) {
    // Get the version from the gradle.properties file
    def version = project.properties["${project.name}-version"]

    if (!version) {
        throw new NullPointerException("Could not find version for " + project.name)
    }

    if (grgit == null) {
        return version + "+nogit"
    }

    def latestCommits = grgit.log(paths: [project.name], maxCommits: 1)

    if (latestCommits.isEmpty()) {
        return version + "+uncommited"
    }

    return version + "+" + latestCommits.get(0).id.substring(0, 8) + DigestUtils.sha256Hex(project.rootProject.minecraft_version).substring(0, 2)
}

def getAddon(project) {
    // Get the version from the gradle.properties file


    if (grgit == null) {
        return "+nogit"
    }

    def latestCommits = grgit.log(paths: [project.name], maxCommits: 1)

    if (latestCommits.isEmpty()) {
        return "+uncommited"
    }

    return "+" + latestCommits.get(0).id.substring(0, 8) + DigestUtils.sha256Hex(project.rootProject.minecraft_version).substring(0, 2)
}


allprojects {
    apply plugin: 'fabric-loom'
    apply plugin: 'maven-publish'
    apply plugin: 'signing'

    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17

    archivesBaseName = project.archives_base_name
    //version = project.mod_version
    //group = "io.github.limeappleboat.thonkutil"
    group = project.maven_group

    repositories {
        maven { url "https://maven.terraformersmc.com/releases" }
        maven {
            name = "Ladysnake Libs"
            url = "https://ladysnake.jfrog.io/artifactory/mods"
        }
        maven { url 'https://jitpack.io' }
        maven {
            url "https://cursemaven.com"
        }

        mavenCentral()
        // Add repositories to retrieve artifacts from in here.
        // You should only use this when depending on other mods because
        // Loom adds the essential maven repositories to download Minecraft and libraries from automatically.
        // See https://docs.gradle.org/current/userguide/declaring_repositories.html
        // for more information about repositories.
    }

    tasks.withType(GenerateModuleMetadata) {
        enabled = false
    }

    loom {
        shareRemapCaches = true
    }


    dependencies {
        // To change the versions see the gradle.properties file
        minecraft "com.mojang:minecraft:${project.minecraft_version}"
        mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
        modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

        // Fabric API. This is technically optional, but you probably want it anyway.
        modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"

        modImplementation "com.terraformersmc:modmenu:3.0.0", {
            exclude module: "fabric-api"
        }

        modImplementation "dev.emi:trinkets:3.3.0"
        modImplementation "curse.maven:waveycapes-521594:3695381"
        // PSA: Some older mods, compiled on Loom 0.2.1, might have outdated Maven POMs.
        // You may need to force-disable transitiveness on them.
    }

    afterEvaluate {
        artifacts {
            dev file: file("${project.buildDir}/libs/$archivesBaseName-${version}-dev.jar"), type: "jar", builtBy: jar
        }
    }

    repositories {
        mavenLocal()
    }

    configurations {
        dev
    }

    processResources {
        inputs.property "version", project.version

        filesMatching("fabric.mod.json") {
            expand "version": project.version
        }
    }

    tasks.withType(JavaCompile).configureEach {
        // ensure that the encoding is set to UTF-8, no matter what the system default is
        // this fixes some edge cases with special characters not displaying correctly
        // see http://yodaconditions.net/blog/fix-for-java-file-encoding-problems-with-gradle.html
        // If Javadoc is generated, this must be specified in that task too.
        it.options.encoding = "UTF-8"

        // Minecraft 1.17 (21w19a) upwards uses Java 17.
        it.options.release = 17
    }

    java {
        // Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
        // if it is present.
        // If you remove this line, sources will not be generated.
        withSourcesJar()
    }
    jar {
        from("LICENSE") {
            rename { "${it}_${project.archivesBaseName}" }
        }
    }

    task moduleJavadocJar(type: Jar) {
        classifier = 'javadoc'
        from javadoc
    }
    build.dependsOn moduleJavadocJar

    signing {
        //useGpgCmd()
        sign moduleJavadocJar
        sign sourcesJar
        sign remapSourcesJar
    }

// configure the maven publication
}

task remapMavenJar(type: RemapJarTask, dependsOn: remapJar) {
    input = jar.archiveFile
    archiveFileName = "${archivesBaseName}-${project.version}-maven.jar"
    addNestedDependencies = false
}
build.dependsOn remapMavenJar

javadoc {
    options {
        source = "17"
        encoding = "UTF-8"
        charSet = "UTF-8"
        memberLevel = JavadocMemberLevel.PACKAGE
        links(
                "https://guava.dev/releases/21.0/api/docs/",
                "https://asm.ow2.io/javadoc/",
                "https://docs.oracle.com/javase/8/docs/api/",
                "http://jenkins.liteloader.com/job/Mixin/javadoc/",
                "https://logging.apache.org/log4j/2.x/log4j-api/apidocs/"
                // Need to add minecraft jd publication etc once there is one available
        )
        // Disable the crazy super-strict doclint tool in Java 8
        addStringOption("Xdoclint:none", "-quiet")
    }

    allprojects.each {
        source(it.sourceSets.main.allJava.srcDirs)
    }

    classpath = sourceSets.main.compileClasspath
    include("**/api/**")
    failOnError false
}
build.dependsOn remapMavenJar

task javadocJar(type: Jar) {
    dependsOn javadoc
    from javadoc.destinationDir
    //Set as `fatjavadoc` to prevent an ide form trying to use this javadoc, over using the modules javadoc
    archiveClassifier = "fatjavadoc"
}

build.dependsOn javadocJar
publishing {
    publications {
        mavenJava(MavenPublication) {
            artifact(remapMavenJar) {
                builtBy remapMavenJar
            }

            artifact(sourcesJar) {
                builtBy remapSourcesJar
            }
            artifact javadocJar

            artifact(moduleJavadocJar) {
                builtBy moduleJavadocJar
            }

            pom.withXml {
                asNode().appendNode("name", project.group + ":" + project.name)
                asNode().appendNode("description", "Modular api for Minecraft mods.")
                asNode().appendNode("url", "https://github.com/LimeAppleBoat/ThonkUtil/")
                def licenses = asNode().appendNode("licenses")
                def license = licenses.appendNode("license")
                license.appendNode("name", "CC0 1.0 Universal")
                license.appendNode("url", "https://github.com/LimeAppleBoat/ThonkUtil/blob/1.18/LICENSE")
                def developers = asNode().appendNode("developers")
                def developer = developers.appendNode("developer")
                developer.appendNode("name", "Joseph Yap")
                developer.appendNode("email", "joseph_calvin_yap@hotmail.com")
                developer.appendNode("organization", "LimeAppleBoat")
                developer.appendNode("organizationUrl", "https://github.com/LimeAppleBoat")
                def scm = asNode().appendNode("scm")
                scm.appendNode("connection", "scm:git:git://github.com/LimeAppleBoat/ThonkUtil.git")
                scm.appendNode("developerConnection", "scm:git:ssh://github.com:LimeAppleBoat/ThonkUtil.git")
                scm.appendNode("url", "https://github.com/LimeAppleBoat/ThonkUtil/tree/1.18/")
                def depsNode = asNode().appendNode("dependencies")
                subprojects.each {
                    if (it.name in dontUse) return
                    def depNode = depsNode.appendNode("dependency")
                    depNode.appendNode("groupId", it.group)
                    depNode.appendNode("artifactId", it.name)
                    depNode.appendNode("version", it.version)
                    depNode.appendNode("scope", "compile")
                }
            }
        }
    }
    setupRepositories(repositories)
}

subprojects.each { remapJar.dependsOn("${it.path}:remapJar") }


subprojects {
    publishing {
        publications {
            mavenJava(MavenPublication) {

                // add all the jars that should be included when publishing to maven
                artifact(remapJar) {
                    builtBy remapJar
                }
                artifact(sourcesJar) {
                    builtBy remapSourcesJar
                }

                artifact(moduleJavadocJar) {
                    builtBy moduleJavadocJar
                }
            }
        }
        setupRepositories(repositories)
    }
    loom.disableDeprecatedPomGeneration(publishing.publications.mavenJava)
    javadoc.enabled = false

    runClient {
        enabled = false
    }
    runServer {
        enabled = false
    }

    afterEvaluate {
        // Disable the gen sources task on sub projects
        genSourcesWithFernFlower.enabled = false
        genSourcesWithCfr.enabled = false
        unpickJar.enabled = false
    }
}
loom.disableDeprecatedPomGeneration(publishing.publications.mavenJava)

dontInclude.addAll(dontUse)

dependencies {
    afterEvaluate {
        subprojects.each {
            if (!(it.name in dontUse)) {
                api project(path: ":${it.name}", configuration: "namedElements")

                if (!(it.name in dontInclude)) {
                    include project("${it.name}:")
                }
            }

            //testmodImplementation project("${it.name}:").sourceSets.testmod.output
        }
    }
}

tasks.withType(Jar).configureEach {
    manifest {
        attributes 'Implementation-Title': 'ThonkUtil',
                'Implementation-Version': project.version,
                'Main-Class': 'com.jab125.thonkutil.Main'
    }
}
allprojects {
    signing {
        sign remapMavenJar
        sign publishing.publications.mavenJava

//    sign sourcesJar
//    sign remapSourcesJar
//    sign moduleJavadocJar
        sign javadocJar
    }
}

subprojects {
    try {
        tasks.publishMavenJavaPublicationToMavenLocal.mustRunAfter signSourcesJar
        tasks.publishMavenJavaPublicationToMavenLocal.mustRunAfter signModuleJavadocJar
    } catch (Exception e) {}
}

try {
    tasks.publishMavenJavaPublicationToMavenLocal.dependsOn(signModuleJavadocJar)
    tasks.publishMavenJavaPublicationToMavenLocal.dependsOn(signSourcesJar)
    tasks.publishMavenJavaPublicationToMavenLocal.dependsOn(signJavadocJar)
    tasks.publishMavenJavaPublicationToMavenLocal.dependsOn(signRemapMavenJar)
    subprojects.each {
        tasks.publishMavenJavaPublicationToMavenLocal.dependsOn("${it.path}:signJavadocJar")
        tasks.publishMavenJavaPublicationToMavenLocal.dependsOn("${it.path}:signmoduleJavadocJar")
        tasks.publishMavenJavaPublicationToMavenLocal.dependsOn("${it.path}:signRemapMavenJar")
    }
} catch (Exception e) {}

void setupRepositories(RepositoryHandler repositories) {
    //repositories.mavenLocal() // uncomment for testing
    def ENV = System.getenv()
    if (ENV.MAVEN_URL) {
        repositories.maven {
            url ENV.MAVEN_URL
            if (ENV.MAVEN_USERNAME) {
                credentials {
                    username ENV.MAVEN_USERNAME
                    password ENV.MAVEN_PASSWORD
                }
            }
        }
    }
}

remapJar {
    afterEvaluate {
        subprojects.each {
            if (it.name in dontInclude) return
            nestedJars.from project("${it.name}:").tasks.getByName("remapJar")
            // Include the signed or none signed jar from the sub project.
            //nestedJars.from project("${it.name}:").tasks.getByName(signingEnabled ? "signRemapJar" : "remapJar")
        }
    }
}

curseforge {
    if (ENV.CURSEFORGE_API_KEY) {
        apiKey = ENV.CURSEFORGE_API_KEY
        if (project.prerelease == "pre-alpha") return
    }

    project {
        id = "536648"
        changelog = ENV.CHANGELOG ?: "No changelog provided"
        releaseType = project.prerelease == "true" ? "beta" : project.prerelease == "alpha" ? "alpha" : "release"
        addGameVersion "1.18.2"
        addGameVersion "1.18-Snapshot"
        addGameVersion "Fabric"
        addGameVersion "Java 17"

        mainArtifact(remapJar) {
            displayName = "[$project.minecraft_version] ThonkUtil $project.version"
            relations {
                requiredDependency 'fabric-api'
                optionalDependency 'trinkets-fabric'
            }
        }

        afterEvaluate {
            uploadTask.dependsOn("remapJar")
        }
    }

    options {
        forgeGradleIntegration = false
        debug = ENV.GITHUB_RUN_NUMBER ? false : true
    }
}

task github(dependsOn: remapMavenJar) {
    onlyIf {
        ENV.GITHUB_TOKEN
        project.prerelease != "pre-alpha"
    }

    doLast {
        def github = GitHub.connectUsingOAuth(ENV.GITHUB_TOKEN as String)
        def repository = github.getRepository(ENV.GITHUB_REPOSITORY)

        def releaseBuilder = new GHReleaseBuilder(repository, version as String)
        releaseBuilder.name("[$project.minecraft_version] ThonkUtil $project.version")
        releaseBuilder.body(ENV.CHANGELOG ?: "No changelog provided")
        releaseBuilder.commitish(getBranch())
        releaseBuilder.prerelease(project.prerelease == "true" || project.prerelease == "alpha")

        def ghRelease = releaseBuilder.create()
        ghRelease.uploadAsset(file("${project.buildDir}/libs/${archivesBaseName}-${version}.jar"), "application/java-archive");
    }
}

allprojects {
    if (it.name in dontUse) {
        System.out.println("Not using " + it.name)
        it.tasks.generatePomFileForMavenJavaPublication.enabled = false
        it.tasks.publishToMavenLocal.enabled = false
        it.tasks.publish.enabled = false
        it.tasks.publishMavenJavaPublicationToMavenLocal.enabled = false
        try {
            it.tasks.publishMavenJavaPublicationToMavenRepository.enabled = false
        } catch (Exception ignored){}
    }
}
apply from: "gradle/module-versioning.gradle"